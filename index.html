<!DOCTYPE html>
<html lang="fr">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Flot Maximal - Graphes avec fl√®ches orient√©es</title>
<style>
  body {
    font-family: sans-serif;
    margin: 0;
    display: flex;
    height: 100vh;
    overflow: hidden;
  }
  #left-panel {
    flex: 1;
    position: relative;
  }
  #controls {
    position: absolute;
    top: 10px; left: 10px;
    background: #f0f0f0;
    padding: 10px;
    border-radius: 8px;
    z-index: 20;
  }
  svg {
    width: 100%;
    height: 100vh;
    background-color: #fafafa;
    cursor: grab;
  }
  .node {
    fill: #2196F3;
    stroke: #fff;
    stroke-width: 2px;
    cursor: pointer;
  }
  .arc {
    stroke: #555;
    stroke-width: 2px;
    marker-end: url(#arrow);
  }
  .label {
    fill: #000;
    font-size: 14px;
    pointer-events: none;
  }
  #right-panel {
    width: 400px;
    overflow-y: auto;
    border-left: 1px solid #ddd;
    padding: 10px;
    box-sizing: border-box;
  }
  table {
    width: 100%;
    border-collapse: collapse;
    margin-bottom: 20px;
  }
  table th, table td {
    border: 1px solid #ccc;
    padding: 6px 8px;
    text-align: center;
  }
  table th {
    background-color: #eee;
  }
  input[type="text"], input[type="number"], select {
    width: 100%;
    box-sizing: border-box;
    padding: 4px;
  }
  button {
    cursor: pointer;
  }
  .arc.active {
    stroke: green;
  }
  .arc.saturated {
    stroke: red;
    stroke-width: 2px;
  }

</style>
</head>
<body>
  <div id="left-panel">
    <div id="controls">
      <label>
        <input type="radio" name="mode" value="node" checked onchange="mode = 'node'">Ajouter Noeud
      </label>
      <label style="margin-left: 10px;">
        <input type="radio" name="mode" value="arc" onchange="mode = 'arc'">Ajouter Arc
      </label>

      <button onclick="executerFlotTotal()">Calculer Flot Max</button>
      <button onclick="reinitialiserArcs()">üîÑ Actualiser</button>

      <br><br>
      <label>D√©part:</label><input id="start" type="text" size="1" />
      <label>Arriv√©e:</label><input id="end" type="text" size="1" />
    </div>
    <svg id="svg"></svg>
  </div>

  <div id="right-panel">
    <h3>Liste des N≈ìuds</h3>
    <table id="node-table">
      <thead>
        <tr><th>Nom</th><th>Actions</th></tr>
      </thead>
      <tbody></tbody>
    </table>

    <h3>Liste des Arcs</h3>
    <table id="arc-table">
      <thead>
        <tr><th>D√©but</th><th>Fin</th><th>Capacit√©</th><th>Restant</th><th>√âtat</th><th>Actions</th></tr>
      </thead>
      <tbody></tbody>
    </table>
  </div>

<script>
  let svg = document.getElementById("svg");
  svg.addEventListener('contextmenu', e => e.preventDefault());

  let mode = "node";
  let nodes = [];
  let arcs = [];
  let nodeId = 0;
  let selectedNode = null;
  let draggingNode = null;

function draw() {
  svg.innerHTML = `
    <defs>
      <marker id="arrow" markerWidth="10" markerHeight="10" refX="6" refY="3" orient="auto" markerUnits="strokeWidth">
        <path d="M0,0 L0,6 L9,3 z" fill="#555" />
      </marker>
    </defs>`;

  // üîÅ Dessin des arcs
  arcs.forEach(arc => {
    // vecteur unitaire
    const dx = arc.target.x - arc.source.x;
    const dy = arc.target.y - arc.source.y;
    const length = Math.sqrt(dx * dx + dy * dy);
    const unitX = dx / length;
    const unitY = dy / length;
    const r = 20; // rayon du noeud

    const startX = arc.source.x + unitX * r;
    const startY = arc.source.y + unitY * r;
    const endX = arc.target.x - unitX * r;
    const endY = arc.target.y - unitY * r;

    // ligne
    let path = document.createElementNS("http://www.w3.org/2000/svg", "path");
    path.setAttribute("d", `M${startX} ${startY} L${endX} ${endY}`);
    let className = "arc";
    if (arc.etat === "satur√©") className += " saturated";
    else if (arc.etat === "bloqu√©") className += " active";
    path.setAttribute("class", arc.highlight ? className + " highlighted" : className);

    path.setAttribute("marker-end", "url(#arrow)");

    // ‚öôÔ∏è Modifier capacit√©
    path.addEventListener('click', e => {
      e.preventDefault();
      let newCap = prompt("Modifier capacit√©:", arc.cap);
      if (newCap !== null) {
        let val = Number(newCap);
        if (!isNaN(val) && val >= 0) {
          arc.cap = val;
          draw();
          refreshArcTable();
        } else {
          alert("Capacit√© invalide !");
        }
      }
    });

    // ‚ùå Supprimer
    path.addEventListener('contextmenu', e => {
      e.preventDefault();
      if (confirm(`Supprimer l'arc ${arc.source.id} ‚Üí ${arc.target.id} ?`)) {
        arcs = arcs.filter(a => a !== arc);
        draw();
        refreshArcTable();
      }
    });

    svg.appendChild(path);

    // texte de capacit√©
    const midX = (startX + endX) / 2;
    const midY = (startY + endY) / 2;
    let text = document.createElementNS("http://www.w3.org/2000/svg", "text");
    text.setAttribute("x", midX);
    text.setAttribute("y", midY);
    text.setAttribute("class", "label");
    text.textContent = arc.cap;
    svg.appendChild(text);
  });

  // üîÅ Dessin des n≈ìuds
  nodes.forEach(node => {
    let circle = document.createElementNS("http://www.w3.org/2000/svg", "circle");
    circle.setAttribute("cx", node.x);
    circle.setAttribute("cy", node.y);
    circle.setAttribute("r", 20);
    circle.setAttribute("class", "node");

    circle.onmousedown = () => { draggingNode = node; };
    circle.ondblclick = () => {
      if (confirm("Supprimer ce noeud ?")) {
        arcs = arcs.filter(a => a.source !== node && a.target !== node);
        nodes = nodes.filter(n => n !== node);
        draw();
        refreshNodeTable();
        refreshArcTable();
      }
    };

    svg.appendChild(circle);

    let text = document.createElementNS("http://www.w3.org/2000/svg", "text");
    text.setAttribute("x", node.x - 7);
    text.setAttribute("y", node.y + 5);
    text.setAttribute("class", "label");
    text.textContent = node.id;
    svg.appendChild(text);
  });
}

  svg.onmousedown = e => {
    if (mode === "node") {
      let newId = generateUniqueNodeId();
      nodes.push({ id: newId, x: e.offsetX, y: e.offsetY });
      draw();
      refreshNodeTable();
      refreshArcTable();
    } else if (mode === "arc") {
      selectedNode = nodes.find(n => Math.hypot(n.x - e.offsetX, n.y - e.offsetY) < 20);
    }
  };

 svg.onmouseup = e => {
  if (mode === "arc" && selectedNode) {
    let targetNode = nodes.find(n => Math.hypot(n.x - e.offsetX, n.y - e.offsetY) < 20);
    if (targetNode && targetNode !== selectedNode) {
      let capStr = prompt("Capacit√© de l'arc:", "10");
      let cap = Number(capStr);
      if (capStr !== null && !isNaN(cap) && cap >= 0) {
        arcs.push({
          source: selectedNode,
          target: targetNode,
          cap,
          restant: cap,  // <-- ici
          etat: "initial"
        });

        draw();
        refreshArcTable();
      } else {
        alert("Capacit√© invalide !");
      }
    }
    selectedNode = null;
  }
  draggingNode = null;
};


  svg.onmousemove = e => {
    if (draggingNode) {
      draggingNode.x = e.offsetX;
      draggingNode.y = e.offsetY;
      draw();
      refreshArcTable();
    }
  };

  function generateUniqueNodeId() {
    function idToStr(num) {
      let s = "";
      while (num >= 0) {
        s = String.fromCharCode(65 + (num % 26)) + s;
        num = Math.floor(num / 26) - 1;
      }
      return s;
    }
    let i = 0;
    while(true) {
      let candidate = idToStr(i);
      if (!nodes.find(n => n.id === candidate)) return candidate;
      i++;
    }
  }

  function refreshNodeTable() {
    let tbody = document.querySelector("#node-table tbody");
    tbody.innerHTML = "";
    nodes.forEach((node, idx) => {
      let tr = document.createElement("tr");

      let tdName = document.createElement("td");
      let inputName = document.createElement("input");
      inputName.type = "text";
      inputName.value = node.id;
      inputName.maxLength = 3;
      inputName.style.textTransform = "uppercase";

      inputName.onchange = () => {
        let newName = inputName.value.toUpperCase().trim();
        if (!newName) {
          alert("Le nom ne peut pas √™tre vide.");
          inputName.value = node.id;
          return;
        }
        if (nodes.some((n,i) => n.id === newName && i !== idx)) {
          alert("Ce nom est d√©j√† utilis√©.");
          inputName.value = node.id;
          return;
        }
        let oldName = node.id;
        node.id = newName;
        arcs.forEach(arc => {
          if (arc.source === node) arc.source.id = newName;
          if (arc.target === node) arc.target.id = newName;
        });
        draw();
        refreshArcTable();
      };

      tdName.appendChild(inputName);
      tr.appendChild(tdName);

      let tdAction = document.createElement("td");
      let btnSuppr = document.createElement("button");
      btnSuppr.textContent = "Supprimer";
      btnSuppr.onclick = () => {
        if (confirm(`Supprimer le noeud ${node.id} ?`)) {
          arcs = arcs.filter(a => a.source !== node && a.target !== node);
          nodes.splice(idx, 1);
          draw();
          refreshNodeTable();
          refreshArcTable();
        }
      };
      tdAction.appendChild(btnSuppr);
      tr.appendChild(tdAction);

      tbody.appendChild(tr);
    });
    

    if(nodes.length === 0) {
      let tr = document.createElement("tr");
      let td = document.createElement("td");
      td.colSpan = 2;
      td.textContent = "Aucun n≈ìud.";
      tr.appendChild(td);
      tbody.appendChild(tr);
    }
  }

  function refreshArcTable() {
    let tbody = document.querySelector("#arc-table tbody");
    tbody.innerHTML = "";
    arcs.forEach((arc, idx) => {
      let tr = document.createElement("tr");

      let tdStart = document.createElement("td");
      tdStart.textContent = arc.source.id;
      tr.appendChild(tdStart);

      let tdEnd = document.createElement("td");
      tdEnd.textContent = arc.target.id;
      tr.appendChild(tdEnd);

      let tdCap = document.createElement("td");
      let inputCap = document.createElement("input");
      inputCap.type = "number";
      inputCap.min = 0;
      inputCap.value = arc.cap;
      inputCap.style.width = "60px";
      inputCap.addEventListener("change", () => {
        let val = Number(inputCap.value);
        if (isNaN(val) || val < 0) {
          alert("Capacit√© invalide !");
          inputCap.value = arc.cap;
        } else {
          arc.cap = val;
          draw();
        }
      });
      tdCap.appendChild(inputCap);
      tr.appendChild(tdCap);
    // Colonne "Restant"
    let tdRestant = document.createElement("td");
    let inputRestant = document.createElement("input");
    inputRestant.type = "number";
    inputRestant.min = 0;
    inputRestant.value = arc.restant;
    inputRestant.style.width = "60px";
    inputRestant.addEventListener("change", () => {
      let val = Number(inputRestant.value);
      if (isNaN(val) || val < 0 || val > arc.cap) {
        alert("Valeur restante invalide ! Elle doit √™tre comprise entre 0 et la capacit√©.");
        inputRestant.value = arc.restant;
      } else {
        arc.restant = val;
        draw();
      }
    });
    tdRestant.appendChild(inputRestant);
    tr.appendChild(tdRestant);

      let tdEtat = document.createElement("td");
      let selectEtat = document.createElement("select");
      ["initial", "bloqu√©", "satur√©"].forEach(val => {
        let opt = document.createElement("option");
        opt.value = val;
        opt.textContent = val;
        if (val === arc.etat) opt.selected = true;
        selectEtat.appendChild(opt);
      });
      selectEtat.addEventListener("change", () => {
        arc.etat = selectEtat.value;
      });
      tdEtat.appendChild(selectEtat);
      tr.appendChild(tdEtat);


      let tdActions = document.createElement("td");
      let btnSuppr = document.createElement("button");
      btnSuppr.textContent = "Supprimer";
      btnSuppr.onclick = () => {
        if (confirm(`Supprimer l'arc ${arc.source.id} ‚Üí ${arc.target.id} ?`)) {
          arcs.splice(idx, 1);
          draw();
          refreshArcTable();
        }
      };
      tdActions.appendChild(btnSuppr);
      tr.appendChild(tdActions);

      tbody.appendChild(tr);
    });

    if (arcs.length === 0) {
      let tr = document.createElement("tr");
      let td = document.createElement("td");
      td.colSpan = 4;
      td.textContent = "Aucun arc.";
      tr.appendChild(td);
      tbody.appendChild(tr);
    }
  }

  //recherche minimum
function rechercheMinimum() {
  let arcMin = null;
  let minRestant = Infinity;

  for (let arc of arcs) {
    if (arc.restant > 0 && arc.etat === "initial" && arc.restant < minRestant) {
      minRestant = arc.restant;
      arcMin = arc;
    }
  }

  return arcMin;
}

///recherche chemin
function rechercheChemin(minimumArc) {
  let startId = document.getElementById("start").value.toUpperCase().trim();
  let endId = document.getElementById("end").value.toUpperCase().trim();

  if (!startId || !endId || startId === endId) {
    alert("D√©part ou arriv√©e invalide !");
    return;
  }

  let cheminsValides = [];

  function dfs(currentNode, path, arcPath) {
    if (currentNode === endId) {
      if (arcPath.includes(minimumArc)) {
        cheminsValides.push([...path]);
      }
      return;
    }

    for (let arc of arcs) {
      if (
        arc.source.id === currentNode &&
        arc.etat === "initial" &&
        arc.restant > 0 &&
        !path.includes(arc.target.id)
      ) {
        path.push(arc.target.id);
        arcPath.push(arc);
        dfs(arc.target.id, path, arcPath);
        path.pop();
        arcPath.pop();
      }
    }
  }

  dfs(startId, [startId], []);

  // ‚úÖ TRIER les chemins par ordre croissant du nombre de sommets
  cheminsValides.sort((a, b) => a.length - b.length);

  if (cheminsValides.length > 0) {
    alert(
      `‚úîÔ∏è Chemin(s) contenant l'arc minimum (${minimumArc.source.id} ‚Üí ${minimumArc.target.id}) = ${minimumArc.restant} :\n` +
      cheminsValides.map(p => p.join(" -> ")).join("\n")
    );
  } else {
    alert("‚ùå Aucun chemin contenant l'arc minimum trouv√©.");
  }

  // üëâ (optionnel) Mettre en √©vidence visuellement
  arcs.forEach(a => a.highlight = false);
  if (minimumArc) {
    minimumArc.highlight = true;
  }
  draw();

  return cheminsValides;
}



function appliquerChemin(chemins) {
  if (!chemins || chemins.length === 0) return;

  // üëá Tu peux ici en choisir un (ex: le premier chemin)
  let chemin = chemins[0]; // Ex: ["A", "B", "D", "F"]

  // üîé R√©cup√®re les arcs correspondant au chemin
  let arcsDuChemin = [];
  for (let i = 0; i < chemin.length - 1; i++) {
    let arc = arcs.find(a =>
      a.source.id === chemin[i] &&
      a.target.id === chemin[i + 1] &&
      a.etat === "initial" &&
      a.restant > 0
    );
    if (arc) arcsDuChemin.push(arc);
    else return alert("Arc manquant ou non disponible entre " + chemin[i] + " et " + chemin[i+1]);
  }

  // üíß Trouver le minimum (le goulot d'√©tranglement)
  let minRestant = Math.min(...arcsDuChemin.map(a => a.restant));

  // üßÆ Appliquer le flot
  arcsDuChemin.forEach(arc => {
    arc.restant -= minRestant;
    if (arc.restant === 0) arc.etat = "satur√©";
    else arc.etat = "initial";
  });

  alert(
    `‚úîÔ∏è Chemin appliqu√© : ${chemin.join(" -> ")}\n` +
    `D√©bit appliqu√© : ${minRestant}`
  );

  draw();
  refreshArcTable();
}




function calculerFlot() {
  let arcMin = rechercheMinimum();
  if (!arcMin) {
    alert("‚ùå Aucun arc avec un restant > 0 !");
    return;
  }

  let cheminsTrouv√©s = rechercheChemin(arcMin);

  if (cheminsTrouv√©s.length === 0) {
    alert("‚ùå Aucun chemin valide trouv√© !");
    return;
  }

  appliquerChemin(cheminsTrouv√©s); // ‚úÖ d√©duit automatiquement le flux et met √† jour les arcs
}

function executerFlotTotal() {
  let totalFlot = 0;
  let iteration = 1;

  while (true) {
    // 1. Trouver un arc minimum encore utilisable
    let arcMin = rechercheMinimum();
    if (!arcMin) break; // ‚úÖ arr√™t si plus d'arc utilisable

    // 2. Trouver un chemin contenant cet arc
    let cheminsTrouv√©s = rechercheChemin(arcMin);
    if (!cheminsTrouv√©s || cheminsTrouv√©s.length === 0) break;

    // 3. R√©cup√©rer les arcs du premier chemin
    let chemin = cheminsTrouv√©s[0];
    let arcsDuChemin = [];

    for (let i = 0; i < chemin.length - 1; i++) {
      let arc = arcs.find(a =>
        a.source.id === chemin[i] &&
        a.target.id === chemin[i + 1] &&
        a.etat === "initial" &&
        a.restant > 0
      );
      if (arc) arcsDuChemin.push(arc);
      else {
        console.warn("Chemin interrompu √† l'√©tape " + i);
        return;
      }
    }

    // 4. Calcul du minimum (bottleneck)
    let minRestant = Math.min(...arcsDuChemin.map(a => a.restant));
    totalFlot += minRestant;

    // 5. Appliquer le flot √† chaque arc
    arcsDuChemin.forEach(arc => {
      arc.restant -= minRestant;
      arc.etat = arc.restant === 0 ? "satur√©" : "initial";
    });

    console.log(`üîÅ Iteration ${iteration}: ${chemin.join(" -> ")} | flot appliqu√©: ${minRestant}`);
    iteration++;
  }

  draw();
  refreshArcTable();
  alert("‚úÖ Flot maximal total appliqu√© : " + totalFlot);
}


//remmettre la valeur du restant = valeur de la capacit√© et etat √† initial
function reinitialiserArcs() {
  arcs.forEach(arc => {
    arc.restant = arc.cap;
    arc.etat = "initial";
  });
  draw();
  refreshArcTable();
}


  draw();
  refreshNodeTable();
  refreshArcTable();
</script>
</body>
</html>
