<!DOCTYPE html>
<html lang="fr">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Flot Maximal - Graphes avec fl√®ches orient√©es</title>
<style>
  body {
    font-family: sans-serif;
    margin: 0;
    display: flex;
    height: 100vh;
    overflow: hidden;
  }
  #left-panel {
    flex: 1;
    position: relative;
  }
  #controls {
    position: absolute;
    top: 10px; left: 10px;
    background: #f0f0f0;
    padding: 10px;
    border-radius: 8px;
    z-index: 20;
  }
  svg {
    width: 100%;
    height: 100vh;
    background-color: #fafafa;
    cursor: grab;
  }
  .node {
    fill: #2196F3;
    stroke: #fff;
    stroke-width: 2px;
    cursor: pointer;
  }
  .arc {
    stroke: #555;
    stroke-width: 2px;
    marker-end: url(#arrow);
  }
  .label {
    fill: #000;
    font-size: 14px;
    pointer-events: none;
  }
  #right-panel {
    width: 400px;
    overflow-y: auto;
    border-left: 1px solid #ddd;
    padding: 10px;
    box-sizing: border-box;
  }
  table {
    width: 100%;
    border-collapse: collapse;
    margin-bottom: 20px;
  }
  table th, table td {
    border: 1px solid #ccc;
    padding: 6px 8px;
    text-align: center;
  }
  table th {
    background-color: #eee;
  }
  input[type="text"], input[type="number"], select {
    width: 100%;
    box-sizing: border-box;
    padding: 4px;
  }
  button {
    cursor: pointer;
  }
  .arc.active {
    stroke: green;
  }
  .arc.saturated {
    stroke: red;
    stroke-width: 2px;
  }

</style>
</head>
<body>
  <div id="left-panel">
    <div id="controls">
      <label>
        <input type="radio" name="mode" value="node" checked onchange="mode = 'node'">Ajouter Noeud
      </label>
      <label style="margin-left: 10px;">
        <input type="radio" name="mode" value="arc" onchange="mode = 'arc'">Ajouter Arc
      </label>

      <button onclick="calculerFlot()">Calculer Flot complet</button>
      <button onclick="reinitialiserArcs()">üîÑ Actualiser</button>

      <br><br>
      <label>D√©part:</label><input id="start" type="text" size="1" />
      <label>Arriv√©e:</label><input id="end" type="text" size="1" />
    </div>
    <svg id="svg"></svg>
  </div>

  <div id="right-panel">
    <h3>Liste des N≈ìuds</h3>
    <table id="node-table">
      <thead>
        <tr><th>Nom</th><th>Actions</th></tr>
      </thead>
      <tbody></tbody>
    </table>

    <h3>Liste des Arcs</h3>
    <table id="arc-table">
      <thead>
        <tr><th>D√©but</th><th>Fin</th><th>Capacit√©</th><th>Restant</th><th>√âtat</th><th>Actions</th></tr>
      </thead>
      <tbody></tbody>
    </table>
    
    <h3>Suivi du Flot</h3>
    <table id="flot-table">
      <thead>
        <tr>
          <th>D√©but</th>
          <th>Fin</th>
          <th>Capacit√©</th>
        </tr>
      </thead>
      <tbody></tbody>
    </table>

  </div>

<script>
  let svg = document.getElementById("svg");
  svg.addEventListener('contextmenu', e => e.preventDefault());

  let mode = "node";
  let nodes = [];
  let arcs = [];
  let nodeId = 0;
  let selectedNode = null;
  let draggingNode = null;

function draw() {
  svg.innerHTML = `
    <defs>
      <marker id="arrow" markerWidth="10" markerHeight="10" refX="6" refY="3" orient="auto" markerUnits="strokeWidth">
        <path d="M0,0 L0,6 L9,3 z" fill="#555" />
      </marker>
    </defs>`;

  // üîÅ Dessin des arcs
  arcs.forEach(arc => {
    // vecteur unitaire
    const dx = arc.target.x - arc.source.x;
    const dy = arc.target.y - arc.source.y;
    const length = Math.sqrt(dx * dx + dy * dy);
    const unitX = dx / length;
    const unitY = dy / length;
    const r = 20; // rayon du noeud

    const startX = arc.source.x + unitX * r;
    const startY = arc.source.y + unitY * r;
    const endX = arc.target.x - unitX * r;
    const endY = arc.target.y - unitY * r;

    // ligne
    let path = document.createElementNS("http://www.w3.org/2000/svg", "path");
    path.setAttribute("d", `M${startX} ${startY} L${endX} ${endY}`);
    let className = "arc";
    if (arc.etat === "satur√©") className += " saturated";
    else if (arc.etat === "bloqu√©") className += " active";
    path.setAttribute("class", arc.highlight ? className + " highlighted" : className);

    path.setAttribute("marker-end", "url(#arrow)");

    // ‚öôÔ∏è Modifier capacit√©
    path.addEventListener('click', e => {
      e.preventDefault();
      let newCap = prompt("Modifier capacit√©:", arc.cap);
      if (newCap !== null) {
        let val = Number(newCap);
        if (!isNaN(val) && val >= 0) {
          arc.cap = val;
          draw();
          refreshArcTable();
        } else {
          alert("Capacit√© invalide !");
        }
      }
    });

    // ‚ùå Supprimer
    path.addEventListener('contextmenu', e => {
      e.preventDefault();
      if (confirm(`Supprimer l'arc ${arc.source.id} ‚Üí ${arc.target.id} ?`)) {
        arcs = arcs.filter(a => a !== arc);
        draw();
        refreshArcTable();
      }
    });

    svg.appendChild(path);

    // texte de capacit√©
    const midX = (startX + endX) / 2;
    const midY = (startY + endY) / 2;
    let text = document.createElementNS("http://www.w3.org/2000/svg", "text");
    text.setAttribute("x", midX);
    text.setAttribute("y", midY);
    text.setAttribute("class", "label");
    text.textContent = arc.cap;
    svg.appendChild(text);
  });

  // üîÅ Dessin des n≈ìuds
  nodes.forEach(node => {
    let circle = document.createElementNS("http://www.w3.org/2000/svg", "circle");
    circle.setAttribute("cx", node.x);
    circle.setAttribute("cy", node.y);
    circle.setAttribute("r", 20);
    circle.setAttribute("class", "node");

    circle.onmousedown = () => { draggingNode = node; };
    circle.ondblclick = () => {
      if (confirm("Supprimer ce noeud ?")) {
        arcs = arcs.filter(a => a.source !== node && a.target !== node);
        nodes = nodes.filter(n => n !== node);
        draw();
        refreshNodeTable();
        refreshArcTable();
      }
    };

    svg.appendChild(circle);

    let text = document.createElementNS("http://www.w3.org/2000/svg", "text");
    text.setAttribute("x", node.x - 7);
    text.setAttribute("y", node.y + 5);
    text.setAttribute("class", "label");
    text.textContent = node.id;
    svg.appendChild(text);
  });
}

  svg.onmousedown = e => {
    if (mode === "node") {
      let newId = generateUniqueNodeId();
      nodes.push({ id: newId, x: e.offsetX, y: e.offsetY });
      draw();
      refreshNodeTable();
      refreshArcTable();
    } else if (mode === "arc") {
      selectedNode = nodes.find(n => Math.hypot(n.x - e.offsetX, n.y - e.offsetY) < 20);
    }
  };

 svg.onmouseup = e => {
  if (mode === "arc" && selectedNode) {
    let targetNode = nodes.find(n => Math.hypot(n.x - e.offsetX, n.y - e.offsetY) < 20);
    if (targetNode && targetNode !== selectedNode) {
      let capStr = prompt("Capacit√© de l'arc:", "10");
      let cap = Number(capStr);
      if (capStr !== null && !isNaN(cap) && cap >= 0) {
        arcs.push({
          source: selectedNode,
          target: targetNode,
          cap,
          restant: cap,  // <-- ici
          etat: "initial"
        });

        draw();
        refreshArcTable();
      } else {
        alert("Capacit√© invalide !");
      }
    }
    selectedNode = null;
  }
  draggingNode = null;
};


  svg.onmousemove = e => {
    if (draggingNode) {
      draggingNode.x = e.offsetX;
      draggingNode.y = e.offsetY;
      draw();
      refreshArcTable();
    }
  };

  function generateUniqueNodeId() {
    function idToStr(num) {
      let s = "";
      while (num >= 0) {
        s = String.fromCharCode(65 + (num % 26)) + s;
        num = Math.floor(num / 26) - 1;
      }
      return s;
    }
    let i = 0;
    while(true) {
      let candidate = idToStr(i);
      if (!nodes.find(n => n.id === candidate)) return candidate;
      i++;
    }
  }

  function refreshNodeTable() {
    let tbody = document.querySelector("#node-table tbody");
    tbody.innerHTML = "";
    nodes.forEach((node, idx) => {
      let tr = document.createElement("tr");

      let tdName = document.createElement("td");
      let inputName = document.createElement("input");
      inputName.type = "text";
      inputName.value = node.id;
      inputName.maxLength = 3;
      inputName.style.textTransform = "uppercase";

      inputName.onchange = () => {
        let newName = inputName.value.toUpperCase().trim();
        if (!newName) {
          alert("Le nom ne peut pas √™tre vide.");
          inputName.value = node.id;
          return;
        }
        if (nodes.some((n,i) => n.id === newName && i !== idx)) {
          alert("Ce nom est d√©j√† utilis√©.");
          inputName.value = node.id;
          return;
        }
        let oldName = node.id;
        node.id = newName;
        arcs.forEach(arc => {
          if (arc.source === node) arc.source.id = newName;
          if (arc.target === node) arc.target.id = newName;
        });
        draw();
        refreshArcTable();
      };

      tdName.appendChild(inputName);
      tr.appendChild(tdName);

      let tdAction = document.createElement("td");
      let btnSuppr = document.createElement("button");
      btnSuppr.textContent = "Supprimer";
      btnSuppr.onclick = () => {
        if (confirm(`Supprimer le noeud ${node.id} ?`)) {
          arcs = arcs.filter(a => a.source !== node && a.target !== node);
          nodes.splice(idx, 1);
          draw();
          refreshNodeTable();
          refreshArcTable();
        }
      };
      tdAction.appendChild(btnSuppr);
      tr.appendChild(tdAction);

      tbody.appendChild(tr);
    });
    

    if(nodes.length === 0) {
      let tr = document.createElement("tr");
      let td = document.createElement("td");
      td.colSpan = 2;
      td.textContent = "Aucun n≈ìud.";
      tr.appendChild(td);
      tbody.appendChild(tr);
    }
  }

  function refreshArcTable() {
    let tbody = document.querySelector("#arc-table tbody");
    tbody.innerHTML = "";
    arcs.forEach((arc, idx) => {
      let tr = document.createElement("tr");

      let tdStart = document.createElement("td");
      tdStart.textContent = arc.source.id;
      tr.appendChild(tdStart);

      let tdEnd = document.createElement("td");
      tdEnd.textContent = arc.target.id;
      tr.appendChild(tdEnd);

      let tdCap = document.createElement("td");
      let inputCap = document.createElement("input");
      inputCap.type = "number";
      inputCap.min = 0;
      inputCap.value = arc.cap;
      inputCap.style.width = "60px";
      inputCap.addEventListener("change", () => {
        let val = Number(inputCap.value);
        if (isNaN(val) || val < 0) {
          alert("Capacit√© invalide !");
          inputCap.value = arc.cap;
        } else {
          arc.cap = val;
          draw();
        }
      });
      tdCap.appendChild(inputCap);
      tr.appendChild(tdCap);
    // Colonne "Restant"
    let tdRestant = document.createElement("td");
    let inputRestant = document.createElement("input");
    inputRestant.type = "number";
    inputRestant.min = 0;
    inputRestant.value = arc.restant;
    inputRestant.style.width = "60px";
    inputRestant.addEventListener("change", () => {
      let val = Number(inputRestant.value);
      if (isNaN(val) || val < 0 || val > arc.cap) {
        alert("Valeur restante invalide ! Elle doit √™tre comprise entre 0 et la capacit√©.");
        inputRestant.value = arc.restant;
      } else {
        arc.restant = val;
        draw();
      }
    });
    tdRestant.appendChild(inputRestant);
    tr.appendChild(tdRestant);

      let tdEtat = document.createElement("td");
      let selectEtat = document.createElement("select");
      ["initial", "bloqu√©", "satur√©"].forEach(val => {
        let opt = document.createElement("option");
        opt.value = val;
        opt.textContent = val;
        if (val === arc.etat) opt.selected = true;
        selectEtat.appendChild(opt);
      });
      selectEtat.addEventListener("change", () => {
        arc.etat = selectEtat.value;
      });
      tdEtat.appendChild(selectEtat);
      tr.appendChild(tdEtat);


      let tdActions = document.createElement("td");
      let btnSuppr = document.createElement("button");
      btnSuppr.textContent = "Supprimer";
      btnSuppr.onclick = () => {
        if (confirm(`Supprimer l'arc ${arc.source.id} ‚Üí ${arc.target.id} ?`)) {
          arcs.splice(idx, 1);
          draw();
          refreshArcTable();
        }
      };
      tdActions.appendChild(btnSuppr);
      tr.appendChild(tdActions);

      tbody.appendChild(tr);
    });

    if (arcs.length === 0) {
      let tr = document.createElement("tr");
      let td = document.createElement("td");
      td.colSpan = 4;
      td.textContent = "Aucun arc.";
      tr.appendChild(td);
      tbody.appendChild(tr);
    }
  }

//remmettre la valeur du restant = valeur de la capacit√© et etat √† initial
function reinitialiserArcs() {
  arcs.forEach(arc => {
    arc.restant = arc.cap;
    arc.etat = "initial";
  });
  draw();
  refreshArcTable();
}




/*suivi du tableau**/
let indexEtape = 1;

// Initialiser le tableau de suivi au d√©but
function initialiserTableauSuivi() {
  const table = document.getElementById("flot-table");
  const thead = table.querySelector("thead");
  const tbody = table.querySelector("tbody");

  // R√©initialise
  thead.innerHTML = `<tr>
    <th>D√©but</th><th>Fin</th><th>Capacit√©</th>
  </tr>`;
  tbody.innerHTML = "";

  // Ajoute les lignes (une par arc)
  arcs.forEach(arc => {
    let tr = document.createElement("tr");
    tr.innerHTML = `
      <td>${arc.source.id}</td>
      <td>${arc.target.id}</td>
      <td>${arc.cap}</td>
    `;
    tbody.appendChild(tr);
  });

  indexEtape = 1; // on recommence les √©tapes
}

// Ajouter une nouvelle colonne de suivi
function ajouterColonneSuivi() {
  const thead = document.querySelector("#flot-table thead tr");
  const tbody = document.querySelector("#flot-table tbody");

  // Cr√©er un nouvel en-t√™te
  const th = document.createElement("th");
  th.textContent = `√âtape ${indexEtape++}`;
  thead.appendChild(th);

  // Ajouter les valeurs correspondantes
  arcs.forEach((arc, idx) => {
    const tr = tbody.children[idx];
    const td = document.createElement("td");

    if (arc.etat === "bloqu√©") {
      td.textContent = "B";
      td.style.backgroundColor = "#ccc";
    } else if (arc.etat === "satur√©") {
      td.textContent = "S";
      td.style.backgroundColor = "#f8d7da";
    } else {
      td.textContent = arc.restant;
    }

    tr.appendChild(td);
  });
}


/*Fonction recherchon l'arc portans le valeur minimum restant et en etat initial pas bloque ni satur√©
 et ainsi retourner le coordonn√©e(deb, fin) avec le valeur restant de l'arc*/
function minimum() {
  let minArc = null;
  let minVal = Infinity;
  arcs.forEach(arc => {
    if (arc.etat === "initial" && arc.restant < minVal && arc.restant > 0) {
      minVal = arc.restant;
      minArc = arc;
    }
  });

  if (minArc) {
    return {
      arc: minArc,
      valeur: minArc.restant
    };
  }
  return null;
}


/*Fonction verifier l'etat de tous les arcs : s'il y a au moins un arc ni bloqu√© ni satur√© elle retourne 
1 sinon elle retourne 0*/
function verifierEtat() {
  return arcs.some(arc => arc.etat === "initial");
}

/*Fonction qui verifie s'il y a un chemin complet du d√©but vers la fin qui passe par l'arc portant me minimum
elle prend en parametre le coordon√© de cette minimum
si aucun chemin complet passe par cette arc retourner aucun sinon retourner un chemin complet*/
function verifierChemin(min) {
  const depart = document.getElementById("start").value.trim().toUpperCase();
  const fin = document.getElementById("end").value.trim().toUpperCase();

  if (!depart || !fin || !min) return null;

  // BFS pour trouver chemin du d√©part au fin passant par min.arc
  let queue = [[depart]];
  let visited = new Set();

  while (queue.length > 0) {
    let path = queue.shift();
    let last = path[path.length - 1];

    if (last === fin) {
      // V√©rifie si le chemin passe par min.arc
      for (let i = 0; i < path.length - 1; i++) {
        if (path[i] === min.arc.source.id && path[i+1] === min.arc.target.id) {
          return path;
        }
      }
    }

    visited.add(last);

    arcs.forEach(arc => {
      if (arc.restant > 0 && arc.etat === "initial" && arc.source.id === last && !visited.has(arc.target.id)) {
        queue.push([...path, arc.target.id]);
      }
    });
  }

  return null;
}



/*fonction de soustraction: cette fonction prend en parametre le chemin complet passans par l'arc portans le minimum
et fais une soustraction sur tous les arcs de cette chemin complet par le valeur de notre minimum
par exemple on a (C,D) = 2 comme minimum et A->B->C->D->E comme chemin complet ; le fonction fais : 
valeur restant du (A,B) - minimu, Valeur restant de (B,C) -minimum et aisi de suite jusqu'a la fin du chemin*/
function soustraction(chemin, minVal) {
  for (let i = 0; i < chemin.length - 1; i++) {
    let source = chemin[i];
    let target = chemin[i + 1];

    let arc = arcs.find(a => a.source.id === source && a.target.id === target);
    if (arc) {
      arc.restant -= minVal;
      if (arc.restant <= 0) {
        arc.restant = 0;
        arc.etat = "satur√©";
      }
    }
  }
}


/*cette fonction est une fonction pour le tableau finale: le permier colonne tous les acrs existe
le deuxi√®me colonne:capacit√© initial; troisi√®me colone valeur du restant apr√®s le premier soustraction 
, 4√®me colone valeur du restant apr√®s le 2√®me soustraction  et insi de suite jusqu'au dernier .
NB: si bloque: valeur du ligne devient B depuis la colonne qu'elle devient bloque et l'avant ne change pas
si satur√© valeur du ligne devient S depuis la colonne qu'elle devient satur√© et l'avant ne change pas
*/
let colonneIndex = 1; // Commence √† 1 car la premi√®re colonne est l'√©tat initial

function addColonne() {
  let table = document.querySelector("#arc-table thead tr");
  let header = document.createElement("th");
  header.textContent = `Restant ${colonneIndex++}`;
  table.appendChild(header);

  document.querySelectorAll("#arc-table tbody tr").forEach((row, idx) => {
    const arc = arcs[idx];
    let td = document.createElement("td");

    if (arc.etat === "bloqu√©") td.textContent = "B";
    else if (arc.etat === "satur√©") td.textContent = "S";
    else td.textContent = arc.restant;

    row.appendChild(td);
  });
}


/*cette fonction calcul le flot complet
  appelle le fonction verifierEtat en premier
  tanque verifierEtat != 0 faire
      appeler minimum(); min = minimum()
      appeler verifierChemin(min);
      si verifierChemin(min)== aucun alors
            mettre l'etat de l'arc portans le minimum en bloqu√©;
      sinon 
        chemincomplet = verifierChemin(min);
        appeler soustraction(chemincomplet);
        mettre l'etat de l'arc portant le minimun en satur√©
        appeler addColonne()
      finsi
    appeler verifierEtat()pour continuer la boucle jusqu'√† ce qu'il retourne faux
  finfaire;
  NB: √† chaque appelle de minimum elle recherche le nouveau minimum sur le capasit√© restant
*/
function calculerFlot() {
  if (!verifierEtat()) {
    alert("Aucun arc initial. Impossible de commencer.");
    return;
  }

  initialiserTableauSuivi(); // üîÅ R√©initialise le nouveau tableau

  while (verifierEtat()) {
    let min = minimum();
    if (!min) break;

    let chemin = verifierChemin(min);
    if (!chemin) {
      min.arc.etat = "bloqu√©";
    } else {
      soustraction(chemin, min.valeur);
      min.arc.etat = "satur√©";
      addColonne();
    }
     ajouterColonneSuivi(); // ‚ûï Ajoute une colonne apr√®s chaque √©tape
  }

  draw();
  refreshArcTable();
}

  draw();
  refreshNodeTable();
  refreshArcTable();
</script>
</body>
</html>
