

/*
  //recherche minimum
function rechercheMinimum() {
  let arcMin = null;
  let minRestant = Infinity;

  for (let arc of arcs) {
    if (arc.restant > 0 && arc.etat === "initial" && arc.restant < minRestant) {
      minRestant = arc.restant;
      arcMin = arc;
    }
  }

  return arcMin;
}

///recherche chemin
function rechercheChemin(minimumArc) {
  let startId = document.getElementById("start").value.toUpperCase().trim();
  let endId = document.getElementById("end").value.toUpperCase().trim();

  if (!startId || !endId || startId === endId) {
    alert("D√©part ou arriv√©e invalide !");
    return;
  }

  let cheminsValides = [];

  function dfs(currentNode, path, arcPath) {
    if (currentNode === endId) {
      if (arcPath.includes(minimumArc)) {
        cheminsValides.push([...path]);
      }
      return;
    }

    for (let arc of arcs) {
      if (
        arc.source.id === currentNode &&
        arc.etat === "initial" &&
        arc.restant > 0 &&
        !path.includes(arc.target.id)
      ) {
        path.push(arc.target.id);
        arcPath.push(arc);
        dfs(arc.target.id, path, arcPath);
        path.pop();
        arcPath.pop();
      }
    }
  }

  dfs(startId, [startId], []);

  // ‚úÖ TRIER les chemins par ordre croissant du nombre de sommets
  cheminsValides.sort((a, b) => a.length - b.length);

  if (cheminsValides.length > 0) {
    alert(
      `‚úîÔ∏è Chemin(s) contenant l'arc minimum (${minimumArc.source.id} ‚Üí ${minimumArc.target.id}) = ${minimumArc.restant} :\n` +
      cheminsValides.map(p => p.join(" -> ")).join("\n")
    );
  } else {
    alert("‚ùå Aucun chemin contenant l'arc minimum trouv√©.");
  }

  // üëâ (optionnel) Mettre en √©vidence visuellement
  arcs.forEach(a => a.highlight = false);
  if (minimumArc) {
    minimumArc.highlight = true;
  }
  draw();

  return cheminsValides;
}



function appliquerChemin(chemins) {
  if (!chemins || chemins.length === 0) return;

  // üëá Tu peux ici en choisir un (ex: le premier chemin)
  let chemin = chemins[0]; // Ex: ["A", "B", "D", "F"]

  // üîé R√©cup√®re les arcs correspondant au chemin
  let arcsDuChemin = [];
  for (let i = 0; i < chemin.length - 1; i++) {
    let arc = arcs.find(a =>
      a.source.id === chemin[i] &&
      a.target.id === chemin[i + 1] &&
      a.etat === "initial" &&
      a.restant > 0
    );
    if (arc) arcsDuChemin.push(arc);
    else return alert("Arc manquant ou non disponible entre " + chemin[i] + " et " + chemin[i+1]);
  }

  // üíß Trouver le minimum (le goulot d'√©tranglement)
  let minRestant = Math.min(...arcsDuChemin.map(a => a.restant));

  // üßÆ Appliquer le flot
  arcsDuChemin.forEach(arc => {
    arc.restant -= minRestant;
    if (arc.restant === 0) arc.etat = "satur√©";
    else arc.etat = "initial";
  });

  alert(
    `‚úîÔ∏è Chemin appliqu√© : ${chemin.join(" -> ")}\n` +
    `D√©bit appliqu√© : ${minRestant}`
  );

  draw();
  refreshArcTable();
}




function calculerFlot() {
  let arcMin = rechercheMinimum();
  if (!arcMin) {
    alert("‚ùå Aucun arc avec un restant > 0 !");
    return;
  }

  let cheminsTrouv√©s = rechercheChemin(arcMin);

  if (cheminsTrouv√©s.length === 0) {
    alert("‚ùå Aucun chemin valide trouv√© !");
    return;
  }

  appliquerChemin(cheminsTrouv√©s); // ‚úÖ d√©duit automatiquement le flux et met √† jour les arcs
}

function executerFlotTotal() {
  let totalFlot = 0;
  let iteration = 1;

  while (true) {
    // 1. Trouver un arc minimum encore utilisable
    let arcMin = rechercheMinimum();
    if (!arcMin) break; // ‚úÖ arr√™t si plus d'arc utilisable

    // 2. Trouver un chemin contenant cet arc
    let cheminsTrouv√©s = rechercheChemin(arcMin);
    if (!cheminsTrouv√©s || cheminsTrouv√©s.length === 0) break;

    // 3. R√©cup√©rer les arcs du premier chemin
    let chemin = cheminsTrouv√©s[0];
    let arcsDuChemin = [];

    for (let i = 0; i < chemin.length - 1; i++) {
      let arc = arcs.find(a =>
        a.source.id === chemin[i] &&
        a.target.id === chemin[i + 1] &&
        a.etat === "initial" &&
        a.restant > 0
      );
      if (arc) arcsDuChemin.push(arc);
      else {
        console.warn("Chemin interrompu √† l'√©tape " + i);
        return;
      }
    }

    // 4. Calcul du minimum (bottleneck)
    let minRestant = Math.min(...arcsDuChemin.map(a => a.restant));
    totalFlot += minRestant;

    // 5. Appliquer le flot √† chaque arc
    arcsDuChemin.forEach(arc => {
      arc.restant -= minRestant;
      arc.etat = arc.restant === 0 ? "satur√©" : "initial";
    });

    console.log(`üîÅ Iteration ${iteration}: ${chemin.join(" -> ")} | flot appliqu√©: ${minRestant}`);
    iteration++;
  }

  draw();
  refreshArcTable();
  alert("‚úÖ Flot maximal total appliqu√© : " + totalFlot);
}


*/